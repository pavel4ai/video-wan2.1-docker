<html> 
            <head>
                <title>Wan2.1 Infrastructure Test Suite</title>
                <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
                <style>
                    body { font-family: Arial, sans-serif; margin: 20px; }
                    button { padding: 10px 20px; margin: 10px 0; cursor: pointer; }
                    .status { margin: 10px 0; padding: 10px; border: 1px solid #ccc; }
                    .video-list { margin-top: 20px; }
                    .video-item { margin: 10px 0; padding: 10px; border: 1px solid #eee; }
                    .network-test-section { background: #f5f5f5; padding: 20px; border-radius: 5px; margin: 20px 0; }
                    .test-instructions { background: #fff; padding: 15px; border-left: 4px solid #007bff; margin: 10px 0; }
                    .command-block { background: #2d2d2d; color: #fff; padding: 15px; border-radius: 4px; font-family: monospace; margin: 10px 0; }
                    .test-results { margin-top: 15px; }
                    .test-type { font-weight: bold; margin-top: 10px; }
                    .chart-container { width: 90%; max-width: 800px; margin: 20px auto; }
                </style>
            </head>
            <body>
                <h1>Test Control Panel</h1>
                <div>
                    <h2>Video Generation Tests</h2>
                    <div id="videoStatus" class="status">Status: Test running automatically...</div>
                </div>
                <div class="network-test-section">
                    <h2>Network Tests</h2>
                    <div class="test-instructions">
                        <h3>iPerf3 Testing Instructions</h3>
                        <p>The iPerf3 server is running on port 5201. Follow these steps to run network tests from your client:</p>
                        
                        <div class="test-type">1. Basic Bandwidth Test (30 seconds):</div>
                        <div class="command-block">
                            iperf3 -c YOUR_SERVER_IP -p 5201 -t 30 -i 1
                        </div>

                        <div class="test-type">2. Bidirectional Test:</div>
                        <div class="command-block">
                            iperf3 -c YOUR_SERVER_IP -p 5201 -t 30 -i 1 --bidir
                        </div>

                        <div class="test-type">3. UDP Test with Jitter Measurement:</div>
                        <div class="command-block">
                            iperf3 -c YOUR_SERVER_IP -p 5201 -u -b 100M -t 30 -i 1
                        </div>

                        <div class="test-type">4. Multiple Parallel Connections Test:</div>
                        <div class="command-block">
                            iperf3 -c YOUR_SERVER_IP -p 5201 -P 4 -t 30 -i 1
                        </div>

                        <p>Replace YOUR_SERVER_IP with the IP address or hostname of this server.</p>
                        <p>Test Parameters:</p>
                        <ul>
                            <li><code>-t 30</code>: Run test for 30 seconds</li>
                            <li><code>-i 1</code>: Output statistics every 1 second</li>
                            <li><code>-u</code>: Use UDP instead of TCP</li>
                            <li><code>-b 100M</code>: Target bandwidth of 100 Mbits/sec (UDP)</li>
                            <li><code>-P 4</code>: Use 4 parallel connections</li>
                            <li><code>--bidir</code>: Bidirectional test</li>
                        </ul>
                    </div>
                    <button id="startIperfButton" onclick="startIperfServer()">Start iPerf3 Server</button>
                    <div id="networkStatus" class="status">Status: Ready</div>
                    <div id="networkResults" class="test-results"></div>
                </div>
                <div>
                    <h2>System Performance Monitoring</h2>
                    <div id="systemMetrics">
                        Loading metrics...
                    </div>
                </div>
                <div>
                    <h2>Generated Videos</h2>
                    <div id="videoList" class="video-list"></div>
                </div>

                <script>
                    let metricsIntervalId = null;
                    let charts = {};

                    function createOrUpdateChart(ctx, chartId, labels, datasets) {
                        if (charts[chartId]) {
                            charts[chartId].data.labels = labels;
                            charts[chartId].data.datasets.forEach((dataset, index) => {
                                if (datasets[index]) {
                                    dataset.data = datasets[index].data;
                                }
                            });
                            charts[chartId].update('none');
                        } else {
                            charts[chartId] = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: labels,
                                    datasets: datasets
                                },
                                options: {
                                    scales: {
                                        x: {
                                            ticks: { 
                                                autoSkip: true, 
                                                maxTicksLimit: 10,
                                                callback: function(value, index, values) {
                                                    const label = this.getLabelForValue(value);
                                                    return label.split('T')[1]?.split('+')[0] || label;
                                                }
                                            }
                                        },
                                        y: {
                                            beginAtZero: true
                                        }
                                    },
                                    animation: false,
                                    plugins: {
                                        legend: { position: 'top' }
                                    }
                                }
                            });
                        }
                    }

                    function stopMetricsPolling(message = 'Polling stopped.') {
                        if (metricsIntervalId) {
                            clearInterval(metricsIntervalId);
                            metricsIntervalId = null;
                            console.log(message);
                        }
                    }

                    function updateMetricsDisplay() {
                        fetch('/api/metrics')
                            .then(response => {
                                if (!response.ok) {
                                    if (response.status === 404) {
                                         console.log('Metrics endpoint returned 404, assuming test ended.');
                                         document.getElementById('videoStatus').textContent = 'Status: Test ended or metrics unavailable.';
                                         stopMetricsPolling('Metrics endpoint 404. Stopping polling.');
                                         return null;
                                    }
                                    throw new Error(`HTTP error! status: ${response.status}`);
                                }
                                return response.json();
                             })
                            .then(metrics => {
                                if (!metrics) return;

                                const metricsDiv = document.getElementById('systemMetrics');
                                const timestamps = metrics.cpu?.timestamps || metrics.memory?.timestamps || metrics.disk?.timestamps || metrics.gpu?.[0]?.timestamps || [];
                                const shortTimestamps = timestamps.map(ts => ts.split('T')[1]?.split('+')[0] || ts);

                                if (metrics.video_test_active === false && metricsIntervalId) {
                                    document.getElementById('videoStatus').textContent = 'Status: Video generation completed.';
                                    stopMetricsPolling('Video test finished. Stopping metrics polling.');
                                }

                                if (metrics.cpu && metrics.cpu.data) {
                                    const chartId = 'cpuChart';
                                    let canvas = document.getElementById(chartId);
                                    if (!canvas) {
                                        metricsDiv.innerHTML += `<div class="chart-container"><h5>CPU Usage (%)</h5><canvas id="${chartId}"></canvas></div>`;
                                        canvas = document.getElementById(chartId);
                                    }
                                    const datasets = [
                                        { label: '%user', data: metrics.cpu.data['user'] || [], borderColor: 'blue', tension: 0.1 },
                                        { label: '%system', data: metrics.cpu.data['system'] || [], borderColor: 'red', tension: 0.1 },
                                        { label: '%idle', data: metrics.cpu.data['idle'] || [], borderColor: 'green', tension: 0.1 }
                                    ];
                                    createOrUpdateChart(canvas.getContext('2d'), chartId, shortTimestamps, datasets);
                                }

                                if (metrics.memory && metrics.memory.data) {
                                    const chartId = 'memoryChart';
                                    let canvas = document.getElementById(chartId);
                                    if (!canvas) {
                                        metricsDiv.innerHTML += `<div class="chart-container"><h5>Memory Usage (% Used)</h5><canvas id="${chartId}"></canvas></div>`;
                                        canvas = document.getElementById(chartId);
                                    }
                                    const datasets = [
                                        { label: '%memused', data: metrics.memory.data['memused'] || [], borderColor: 'purple', tension: 0.1 }
                                    ];
                                    createOrUpdateChart(canvas.getContext('2d'), chartId, shortTimestamps, datasets);
                                }

                                if (metrics.disk && metrics.disk.data) {
                                    const chartId = 'diskChart';
                                    const deviceName = metrics.disk.device || 'N/A';
                                    let canvas = document.getElementById(chartId);
                                    if (!canvas) {
                                        metricsDiv.innerHTML += `<div class="chart-container"><h5>Disk I/O (kB/s) - ${deviceName}</h5><canvas id="${chartId}"></canvas></div>`;
                                        canvas = document.getElementById(chartId);
                                    }
                                    const datasets = [
                                        { label: 'Read kB/s', data: metrics.disk.data['rkB_s'] || [], borderColor: 'orange', tension: 0.1 },
                                        { label: 'Write kB/s', data: metrics.disk.data['wkB_s'] || [], borderColor: 'brown', tension: 0.1 }
                                    ];
                                    createOrUpdateChart(canvas.getContext('2d'), chartId, shortTimestamps, datasets);
                                }

                                if (metrics.gpu && Array.isArray(metrics.gpu)) {
                                    metrics.gpu.forEach((gpuData, index) => {
                                        const gpuTimestamps = gpuData.timestamps.map(ts => ts.split('T')[1]?.split('+')[0] || ts);

                                        const utilMemChartId = `gpuUtilMemChart_${index}`;
                                        let utilMemCanvas = document.getElementById(utilMemChartId);
                                        if (!utilMemCanvas) {
                                            metricsDiv.innerHTML += `<div class="chart-container"><h5>GPU ${index} Utilization (%) & Memory (MiB)</h5><canvas id="${utilMemChartId}"></canvas></div>`;
                                            utilMemCanvas = document.getElementById(utilMemChartId);
                                        }
                                        const utilMemDatasets = [
                                            { label: 'Util [%]', data: gpuData.data['utilization_gpu'] || [], borderColor: 'lime', tension: 0.1, yAxisID: 'yPercent' },
                                            { label: 'Mem Used [MiB]', data: gpuData.data['memory_used'] || [], borderColor: 'cyan', tension: 0.1, yAxisID: 'yMiB' }
                                        ];
                                        createOrUpdateChart(utilMemCanvas.getContext('2d'), utilMemChartId, gpuTimestamps, utilMemDatasets);

                                        const tempPowerChartId = `gpuTempPowerChart_${index}`;
                                        let tempPowerCanvas = document.getElementById(tempPowerChartId);
                                        if (!tempPowerCanvas) {
                                            metricsDiv.innerHTML += `<div class="chart-container"><h5>GPU ${index} Temp (°C) & Power (W)</h5><canvas id="${tempPowerChartId}"></canvas></div>`;
                                            tempPowerCanvas = document.getElementById(tempPowerChartId);
                                        }
                                        const tempPowerDatasets = [
                                            { label: 'Temp [°C]', data: gpuData.data['temperature_gpu'] || [], borderColor: 'magenta', tension: 0.1 },
                                            { label: 'Power [W]', data: gpuData.data['power_draw'] || [], borderColor: 'gold', tension: 0.1 }
                                        ];
                                        createOrUpdateChart(tempPowerCanvas.getContext('2d'), tempPowerChartId, gpuTimestamps, tempPowerDatasets);
                                    });
                                }

                            })
                            .catch(error => {
                                console.error('Error fetching metrics:', error);
                                document.getElementById('systemMetrics').innerHTML = `Error loading metrics: ${error}. Polling stopped.`;
                                stopMetricsPolling();
                            });
                    }

                    function startIperfServer() {
                        document.getElementById('networkStatus').textContent = 'Status: Starting iPerf3 server...';
                        fetch('/api/start-iperf')
                            .then(response => response.json())
                            .then(data => {
                                document.getElementById('networkStatus').textContent = 'Status: ' + data.message;
                                document.getElementById('startIperfButton').disabled = (data.status === 'started');
                            })
                            .catch(error => {
                                document.getElementById('networkStatus').textContent = 'Status: Error starting iPerf3 - ' + error;
                            });
                    }

                    function updateVideoList() {
                        fetch('/api/videos')
                            .then(response => response.json())
                            .then(videos => {
                                const videoList = document.getElementById('videoList');
                                videoList.innerHTML = videos.map(video => 
                                    '<div class="video-item">' +
                                        '<div>' + video.name + '</div>' +
                                        '<video controls width="400">' +
                                            '<source src="/videos/' + video.name + '" type="video/mp4">' +
                                            'Your browser does not support the video tag.' +
                                        '</video>' +
                                    '</div>'
                                ).join('');
                            })
                            .catch(error => {
                                console.error('Error updating video list:', error);
                            });
                    }

                    metricsIntervalId = setInterval(updateMetricsDisplay, 3000);
                    updateMetricsDisplay();
                    setInterval(updateVideoList, 30000);
                    updateVideoList();
                </script>
            </body>
        </html> 