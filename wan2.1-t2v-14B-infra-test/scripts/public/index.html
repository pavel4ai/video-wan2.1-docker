<html> 
            <head>
                <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-eval' https://cdn.jsdelivr.net">
                <title>Wan2.1 Infrastructure Test Suite</title>
                <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
                <script src="https://cdn.jsdelivr.net/npm/luxon@^2"></script>
                <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@^1"></script>
<script src="main.js"></script>
                <style>
                    body { font-family: Arial, sans-serif; margin: 20px; }
                    button { padding: 10px 20px; margin: 10px 0; cursor: pointer; }
                    .status { margin: 10px 0; padding: 10px; border: 1px solid #ccc; }
                    .video-list { margin-top: 20px; }
                    .video-item { margin: 10px 0; padding: 10px; border: 1px solid #eee; }
                    .network-test-section { background: #f5f5f5; padding: 20px; border-radius: 5px; margin: 20px 0; }
                    .test-instructions { background: #fff; padding: 15px; border-left: 4px solid #007bff; margin: 10px 0; }
                    .command-block { background: #2d2d2d; color: #fff; padding: 15px; border-radius: 4px; font-family: monospace; margin: 10px 0; }
                    .test-results { margin-top: 15px; }
                    .test-type { font-weight: bold; margin-top: 10px; }
                    .chart-container { width: 90%; max-width: 800px; margin: 20px auto; }
                </style>
            </head>
            <body>
                <h1>Test Control Panel</h1>
                <div>
                    <h2>Video Generation Tests</h2>
                    <div id="videoStatus" class="status">Status: Test running automatically...</div>
                </div>
                <div class="network-test-section">
                    <h2>HTTP Speed Test</h2>
                    <button id="startSpeedTestButton">Start Speed Test</button>
                    <div id="speedTestStatus" class="status">Status: Ready</div>
                    <div class="test-results">
                        <div>Ping: <span id="pingResult">---</span> ms</div>
                        <div>Jitter: <span id="jitterResult">---</span> ms</div>
                        <div>Download: <span id="downloadResult">---</span> Mbps</div>
                        <div>Upload: <span id="uploadResult">---</span> Mbps</div>
                    </div>
                </div>
                <div>
                    <h2>System Performance Monitoring</h2>
                    <div id="systemMetrics">
                        Loading metrics...
                    </div>
                </div>
                <div>
                    <h2>Generated Videos</h2>
                    <div id="videoList" class="video-list"></div>
                </div>


                    function createOrUpdateChart(ctx, chartId, labels, datasets) {
                        if (charts[chartId]) {
                            charts[chartId].data.labels = labels;
                            charts[chartId].data.datasets.forEach((dataset, index) => {
                                if (datasets[index]) {
                                    dataset.data = datasets[index].data;
                                }
                            });
                            charts[chartId].update('none');
                        } else {
                            charts[chartId] = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: labels,
                                    datasets: datasets
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: true,
                                    scales: {
                                        x: {
                                            type: 'time',
                                            adapters: {
                                                date: { locale: 'en-US', zone: 'America/New_York' }
                                            },
                                            ticks: { 
                                                autoSkip: true, 
                                                maxTicksLimit: 10,
                                            },
                                            time: {
                                                unit: 'second',
                                                displayFormats: {
                                                    second: 'HH:mm:ss'
                                                },
                                                tooltipFormat: 'yyyy-MM-dd HH:mm:ss ZZZZ'
                                            }
                                        },
                                        y: {
                                            beginAtZero: true
                                        }
                                    },
                                    animation: false,
                                    plugins: {
                                        legend: { position: 'top' }
                                    }
                                }
                            });
                        }
                    }

                    function stopMetricsPolling(message = 'Polling stopped.') {
                        if (metricsIntervalId) {
                            clearInterval(metricsIntervalId);
                            metricsIntervalId = null;
                            console.log(message);
                        }
                    }

                    function updateMetricsDisplay() {
                        fetch('/api/metrics')
                            .then(response => {
                                if (!response.ok) {
                                    if (response.status === 404) {
                                         console.log('Metrics endpoint returned 404, assuming test ended.');
                                         document.getElementById('videoStatus').textContent = 'Status: Test ended or metrics unavailable.';
                                         stopMetricsPolling('Metrics endpoint 404. Stopping polling.');
                                         return null;
                                    }
                                    throw new Error(`HTTP error! status: ${response.status}`);
                                }
                                return response.json();
                             })
                            .then(metrics => {
                                if (!metrics) return;
                                console.log('Received metrics:', JSON.stringify(metrics, null, 2));

                                // Destroy all Chart.js instances before removing canvases
for (const chartId in charts) {
    if (charts[chartId]) {
        charts[chartId].destroy();
    }
}
charts = {};
const metricsDiv = document.getElementById('systemMetrics');
metricsDiv.innerHTML = '';

                                const timestamps = metrics.cpu?.timestamps || metrics.memory?.timestamps || metrics.disk?.timestamps || metrics.gpu?.[0]?.timestamps || [];
                                const luxonTimestamps = timestamps.map(ts => luxon.DateTime.fromISO(ts, { zone: 'utc' }).setZone('America/New_York'));
                                const chartLabels = luxonTimestamps.map(dt => dt.valueOf());

                                if (metrics.video_test_active === false && metricsIntervalId) {
                                    document.getElementById('videoStatus').textContent = 'Status: Video generation completed.';
                                    stopMetricsPolling('Video test finished. Stopping metrics polling.');
                                }

                                if (metrics.cpu && metrics.cpu.data) {
                                    const chartId = 'cpuChart';
                                    let canvas = document.getElementById(chartId);
                                    if (!canvas) {
                                        metricsDiv.innerHTML += `<div class="chart-container"><h5>CPU Usage (%)</h5><canvas id="${chartId}"></canvas></div>`;
                                        canvas = document.getElementById(chartId);
                                    }
                                    const datasets = [
                                        { label: '%user', data: metrics.cpu.data['user'] || [], borderColor: 'blue', tension: 0.1 },
                                        { label: '%system', data: metrics.cpu.data['system'] || [], borderColor: 'red', tension: 0.1 },
                                        { label: '%idle', data: metrics.cpu.data['idle'] || [], borderColor: 'green', tension: 0.1 }
                                    ];
                                    createOrUpdateChart(canvas.getContext('2d'), chartId, chartLabels, datasets);
                                }

                                if (metrics.memory && metrics.memory.data) {
                                    const chartId = 'memoryChart';
                                    let canvas = document.getElementById(chartId);
                                    if (!canvas) {
                                        metricsDiv.innerHTML += `<div class="chart-container"><h5>Memory Usage (% Used)</h5><canvas id="${chartId}"></canvas></div>`;
                                        canvas = document.getElementById(chartId);
                                    }
                                    const datasets = [
                                        { label: '%memused', data: metrics.memory.data['memused'] || [], borderColor: 'purple', tension: 0.1 }
                                    ];
                                    createOrUpdateChart(canvas.getContext('2d'), chartId, chartLabels, datasets);
                                }

                                if (metrics.disk && metrics.disk.data) {
                                    const chartId = 'diskChart';
                                    const deviceName = metrics.disk.device || 'N/A';
                                    let canvas = document.getElementById(chartId);
                                    if (!canvas) {
                                        metricsDiv.innerHTML += `<div class="chart-container"><h5>Disk I/O (kB/s) - ${deviceName}</h5><canvas id="${chartId}"></canvas></div>`;
                                        canvas = document.getElementById(chartId);
                                    }
                                    const datasets = [
                                        { label: 'Read kB/s', data: metrics.disk.data['rkB_s'] || [], borderColor: 'orange', tension: 0.1 },
                                        { label: 'Write kB/s', data: metrics.disk.data['wkB_s'] || [], borderColor: 'brown', tension: 0.1 }
                                    ];
                                    createOrUpdateChart(canvas.getContext('2d'), chartId, chartLabels, datasets);
                                }

                                if (metrics.gpu && Array.isArray(metrics.gpu)) {
                                    metrics.gpu.forEach((gpuData, index) => {
                                        const gpuLuxonTimestamps = gpuData.timestamps.map(ts => luxon.DateTime.fromISO(ts, { zone: 'utc' }).setZone('America/New_York'));
                                        const gpuChartLabels = gpuLuxonTimestamps.map(dt => dt.valueOf());

                                        const utilMemChartId = `gpuUtilMemChart_${index}`;
                                        let utilMemCanvas = document.getElementById(utilMemChartId);
                                        if (!utilMemCanvas) {
                                            metricsDiv.innerHTML += `<div class="chart-container"><h5>GPU ${index} Utilization (%) & Memory (MiB)</h5><canvas id="${utilMemChartId}"></canvas></div>`;
                                            utilMemCanvas = document.getElementById(utilMemChartId);
                                        }
                                        const utilMemDatasets = [
                                            { label: 'Util [%]', data: gpuData.data['utilization_gpu'] || [], borderColor: 'lime', tension: 0.1, yAxisID: 'yPercent' },
                                            { label: 'Mem Used [MiB]', data: gpuData.data['memory_used'] || [], borderColor: 'cyan', tension: 0.1, yAxisID: 'yMiB' }
                                        ];
                                        createOrUpdateChart(utilMemCanvas.getContext('2d'), utilMemChartId, gpuChartLabels, utilMemDatasets);

                                        const tempPowerChartId = `gpuTempPowerChart_${index}`;
                                        let tempPowerCanvas = document.getElementById(tempPowerChartId);
                                        if (!tempPowerCanvas) {
                                            metricsDiv.innerHTML += `<div class="chart-container"><h5>GPU ${index} Temp (°C) & Power (W)</h5><canvas id="${tempPowerChartId}"></canvas></div>`;
                                            tempPowerCanvas = document.getElementById(tempPowerChartId);
                                        }
                                        const tempPowerDatasets = [
                                            { label: 'Temp [°C]', data: gpuData.data['temperature_gpu'] || [], borderColor: 'magenta', tension: 0.1 },
                                            { label: 'Power [W]', data: gpuData.data['power_draw'] || [], borderColor: 'gold', tension: 0.1 }
                                        ];
                                        createOrUpdateChart(tempPowerCanvas.getContext('2d'), tempPowerChartId, gpuChartLabels, tempPowerDatasets);
                                    });
                                }

                            })
                            .catch(error => {
                                console.error('Error fetching metrics:', error);
                                document.getElementById('systemMetrics').innerHTML = `Error loading metrics: ${error}. Polling stopped.`;
                                stopMetricsPolling();
                            });
                    }

                    function updateStatus(message) {
                        document.getElementById('speedTestStatus').textContent = `Status: ${message}`;
                    }

                    async function measurePing(samples = 10) {
                        updateStatus('Testing latency...');
                        let rtts = [];
                        const endpoint = '/api/speedtest/ping';
                        for (let i = 0; i < samples; i++) {
                            const start = performance.now();
                            try {
                                await fetch(endpoint, { cache: 'no-store' }); // Prevent caching
                                const end = performance.now();
                                rtts.push(end - start);
                            } catch (e) {
                                console.error(`Ping ${i+1} failed:`, e);
                                // Optionally skip this sample or throw error
                            }
                            await new Promise(resolve => setTimeout(resolve, 50)); // Small delay between pings
                        }

                        if (rtts.length === 0) throw new Error('Ping test failed completely.');

                        rtts.sort((a, b) => a - b);
                        const minPing = rtts[0];
                        const avgPing = rtts.reduce((a, b) => a + b, 0) / rtts.length;
                        
                        // Calculate jitter (standard deviation)
                        const mean = avgPing;
                        const variance = rtts.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / rtts.length;
                        const jitter = Math.sqrt(variance);
                        
                        document.getElementById('pingResult').textContent = minPing.toFixed(2);
                        document.getElementById('jitterResult').textContent = jitter.toFixed(2);
                        updateStatus('Latency test complete.');
                        return { ping: minPing, jitter: jitter };
                    }

                    async function measureDownload(endpoint = '/api/speedtest/download') {
                        updateStatus('Testing download speed...');
                        const start = performance.now();
                        try {
                            const response = await fetch(endpoint, { cache: 'no-store' });
                            if (!response.ok) throw new Error(`Server error: ${response.status}`);
                            const data = await response.blob(); // Ensure full download
                            const end = performance.now();
                            const durationSeconds = (end - start) / 1000;
                            const sizeBytes = data.size;
                            if (durationSeconds === 0 || sizeBytes === 0) throw new Error('Download test returned no data or took zero time.');
                            const speedMbps = (sizeBytes * 8) / (durationSeconds * 1000 * 1000);
                            document.getElementById('downloadResult').textContent = speedMbps.toFixed(2);
                            updateStatus('Download test complete.');
                            return speedMbps;
                        } catch (e) {
                            document.getElementById('downloadResult').textContent = 'Error';
                            throw new Error(`Download test failed: ${e.message}`);
                        }
                    }

                    async function measureUpload(sizeMB = 10, endpoint = '/api/speedtest/upload') {
                        updateStatus('Testing upload speed...');
                        const sizeBytes = sizeMB * 1024 * 1024;
                        const data = new Blob([new ArrayBuffer(sizeBytes)], {type: 'application/octet-stream'}); // Create blob
                        const start = performance.now();
                        try {
                            const response = await fetch(endpoint, { 
                                method: 'POST', 
                                body: data, 
                                cache: 'no-store' 
                            });
                            if (!response.ok) throw new Error(`Server error: ${response.status}`);
                            const end = performance.now();
                            const durationSeconds = (end - start) / 1000;
                             if (durationSeconds === 0) throw new Error('Upload test took zero time.');
                            const speedMbps = (sizeBytes * 8) / (durationSeconds * 1000 * 1000);
                            document.getElementById('uploadResult').textContent = speedMbps.toFixed(2);
                             updateStatus('Upload test complete.');
                            return speedMbps;
                        } catch (e) {
                            document.getElementById('uploadResult').textContent = 'Error';
                            throw new Error(`Upload test failed: ${e.message}`);
                        }
                    }

                    async function runSpeedTest() {
                        document.getElementById('startSpeedTestButton').disabled = true;
                        document.getElementById('pingResult').textContent = '---';
                        document.getElementById('jitterResult').textContent = '---';
                        document.getElementById('downloadResult').textContent = '---';
                        document.getElementById('uploadResult').textContent = '---';
                        
                        try {
                            await measurePing();
                            await measureDownload();
                            await measureUpload();
                            updateStatus('Speed test finished.');
                        } catch (error) {
                            console.error('Speed test error:', error);
                            updateStatus(`Test failed: ${error.message}`);
                        } finally {
                            document.getElementById('startSpeedTestButton').disabled = false;
                        }
                    }

                    // Fetch videos
                    async function updateVideoList() {
                        fetch('/api/videos')
                            .then(response => response.json())
                            .then(videos => {
                                const videoList = document.getElementById('videoList');
                                videoList.innerHTML = videos.map(video => 
                                    '<div class="video-item">' +
                                        '<div>' + video.name + '</div>' +
                                        '<video controls width="400">' +
                                            '<source src="/videos/' + video.name + '" type="video/mp4">' +
                                            'Your browser does not support the video tag.' +
                                        '</video>' +
                                    '</div>'
                                ).join('');
                            })
                            .catch(error => {
                                console.error('Error updating video list:', error);
                            });
                    }

                    window.addEventListener('DOMContentLoaded', function() {
                        document.getElementById('startSpeedTestButton').addEventListener('click', runSpeedTest);
                        metricsIntervalId = setInterval(updateMetricsDisplay, 3000);
                        updateMetricsDisplay();
                        setInterval(updateVideoList, 30000);
                        updateVideoList();
                    });
            </body>
        </html>